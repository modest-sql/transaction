//Print0 is a dummy function.
func Print0() {
	fmt.Println("FUNCTION CREATE EXCECUTED.")
}

//Print1 is a dummy function.
func Print1() {
	fmt.Println("FUNCTION SELECT EXCECUTED.")
}

//Print2 is a dummy function.
func Print2() {
	fmt.Println("FUNCTION UPDATE EXCECUTED.")
}

//Print3 is a dummy function.
func Print3() {
	fmt.Println("FUNCTION INSERT EXCECUTED.")
}

//Print4 is a dummy function.
func Print4() {
	fmt.Println("FUNCTION DELETE EXCECUTED.")
}

//Print5 is a dummy function.
func Print5() {
	fmt.Println("FUNCTION DROP EXCECUTED.")
}

//Print6 is a dummy function.
func Print6() {
	fmt.Println("FUNCTION ALTER EXCECUTED.")
}

type Table struct {
	Name string
}

func (T Table) TableName() string {
	return T.Name
}

func init() {
	//DEFINIR DELAY Y THREADS EN BASE A UN JSON.
}

//BuildTransactions creates an array of transactions for test purposes.
func BuildTransactions() []Transaction {
	C0 := common.NewCommand(Table{"Table_1"}, 2, Print0)
	C1 := common.NewCommand(Table{"Table_1"}, 1, Print1)
	C2 := common.NewCommand(Table{"Table_1"}, 2, Print2)
	C3 := common.NewCommand(Table{"Table_2"}, 1, Print3)
	C4 := common.NewCommand(Table{"Table_1"}, 1, Print4)
	C5 := common.NewCommand(Table{"Table_1"}, 0, Print5)
	C6 := common.NewCommand(Table{"Table_1"}, 2, Print6)

	COMMANDS := make([]common.Command, 0)
	COMMANDS = append(COMMANDS, C0)
	COMMANDS = append(COMMANDS, C1)
	COMMANDS = append(COMMANDS, C2)
	COMMANDS = append(COMMANDS, C3)
	COMMANDS = append(COMMANDS, C4)
	COMMANDS = append(COMMANDS, C5)
	COMMANDS = append(COMMANDS, C6)

	T := NewTransaction(COMMANDS)

	C0 = common.NewCommand(Table{"Table_2"}, 0, Print0)
	C1 = common.NewCommand(Table{"Table_2"}, 1, Print1)
	C2 = common.NewCommand(Table{"Table_2"}, 2, Print2)
	C3 = common.NewCommand(Table{"Table_3"}, 1, Print1)
	C4 = common.NewCommand(Table{"Table_2"}, 4, Print4)
	C5 = common.NewCommand(Table{"Table_2"}, 5, Print5)
	C6 = common.NewCommand(Table{"Table_5"}, 1, Print1)

	COMMANDS = make([]common.Command, 0)
	COMMANDS = append(COMMANDS, C0)
	COMMANDS = append(COMMANDS, C1)
	COMMANDS = append(COMMANDS, C2)
	COMMANDS = append(COMMANDS, C3)
	COMMANDS = append(COMMANDS, C4)
	COMMANDS = append(COMMANDS, C5)
	COMMANDS = append(COMMANDS, C6)

	T2 := NewTransaction(COMMANDS)

	C0 = common.NewCommand(Table{"Table_2"}, 1, Print0)
	C1 = common.NewCommand(Table{"Table_4"}, 1, Print1)
	C2 = common.NewCommand(Table{"Table_2"}, 2, Print2)
	C3 = common.NewCommand(Table{"Table_3"}, 1, Print1)
	C4 = common.NewCommand(Table{"Table_2"}, 1, Print4)
	C5 = common.NewCommand(Table{"Table_2"}, 1, Print5)
	C6 = common.NewCommand(Table{"Table_5"}, 1, Print1)

	COMMANDS = make([]common.Command, 0)
	COMMANDS = append(COMMANDS, C0)
	COMMANDS = append(COMMANDS, C1)
	COMMANDS = append(COMMANDS, C2)
	COMMANDS = append(COMMANDS, C3)
	COMMANDS = append(COMMANDS, C4)
	COMMANDS = append(COMMANDS, C5)
	COMMANDS = append(COMMANDS, C6)

	T3 := NewTransaction(COMMANDS)

	COMMANDS = make([]common.Command, 0)
	COMMANDS = append(COMMANDS, C0)
	COMMANDS = append(COMMANDS, C1)
	COMMANDS = append(COMMANDS, C2)
	COMMANDS = append(COMMANDS, C3)
	COMMANDS = append(COMMANDS, C4)
	COMMANDS = append(COMMANDS, C5)
	COMMANDS = append(COMMANDS, C6)

	T4 := NewTransaction(COMMANDS)

	C0 = common.NewCommand(Table{"Table_2"}, 0, Print0)
	C1 = common.NewCommand(Table{"Table_2"}, 1, Print1)
	C2 = common.NewCommand(Table{"Table_2"}, 2, Print2)
	C3 = common.NewCommand(Table{"Table_3"}, 1, Print1)
	C4 = common.NewCommand(Table{"Table_2"}, 4, Print4)
	C5 = common.NewCommand(Table{"Table_2"}, 5, Print5)
	C6 = common.NewCommand(Table{"Table_5"}, 1, Print1)

	COMMANDS = make([]common.Command, 0)
	COMMANDS = append(COMMANDS, C0)
	COMMANDS = append(COMMANDS, C1)
	COMMANDS = append(COMMANDS, C2)
	COMMANDS = append(COMMANDS, C3)
	COMMANDS = append(COMMANDS, C4)
	COMMANDS = append(COMMANDS, C5)
	COMMANDS = append(COMMANDS, C6)

	T5 := NewTransaction(COMMANDS)

	TRANSACTIONS := make([]Transaction, 0)
	TRANSACTIONS = append(TRANSACTIONS, T)
	TRANSACTIONS = append(TRANSACTIONS, T2)
	TRANSACTIONS = append(TRANSACTIONS, T3)
	TRANSACTIONS = append(TRANSACTIONS, T4)
	TRANSACTIONS = append(TRANSACTIONS, T5)

	return TRANSACTIONS
}

func main() {

	Transactions := BuildTransactions()

	MutexesMap := new(sync.Map)

	//ADD A RWMUTEX FOR EACH TABLE INVOLVED IN THIS TRANSACTION EXCECUTION QUEUE.
	for i := 0; i < len(Transactions); i++ {
		for j := 0; j < len(Transactions[i].CommandsInTransaction); j++ {
			MutexesMap.Store(Transactions[i].CommandsInTransaction[j].TableName(), &sync.RWMutex{})
		}
	}

	//fmt.Println(MutexesMap)

	//ARRANGE TRANSACTIONS TO MAKE AS MUCH DATA REACH THE CLIENT AS POSSIBLE.
	TRANSACTIONDESIGNATION := make([]int, len(Transactions))
	for i := 0; i < len(Transactions); i++ {
		for j := 0; j < len(Transactions[i].CommandsInTransaction); j++ {
			if Transactions[i].CommandsInTransaction[j].InstructionType == 0 {
				if TRANSACTIONDESIGNATION[i] != 2 {
					TRANSACTIONDESIGNATION[i] = 1
				}
			} else if Transactions[i].CommandsInTransaction[j].InstructionType == 4 || Transactions[i].CommandsInTransaction[j].InstructionType == 5 {
				TRANSACTIONDESIGNATION[i] = 2
			} else {
				//Do nothing
			}
		}
	}

	fmt.Println("Marker Array")
	fmt.Println(TRANSACTIONDESIGNATION)

	REORDEREDTRANSACTIONS := make([]Transaction, 0)

	for i := 0; i < len(Transactions); i++ {
		if TRANSACTIONDESIGNATION[i] == 1 {
			REORDEREDTRANSACTIONS = append(REORDEREDTRANSACTIONS, Transactions[i])
		}
	}
	for i := 0; i < len(Transactions); i++ {
		if TRANSACTIONDESIGNATION[i] == 0 {
			REORDEREDTRANSACTIONS = append(REORDEREDTRANSACTIONS, Transactions[i])
		}
	}

	for i := 0; i < len(Transactions); i++ {
		if TRANSACTIONDESIGNATION[i] == 2 {
			REORDEREDTRANSACTIONS = append(REORDEREDTRANSACTIONS, Transactions[i])
		}
	}

	fmt.Println("TRANSACTIONDESIGNATION[] despues de ordenamiento.")

	TRANSACTIONDESIGNATION = make([]int, len(REORDEREDTRANSACTIONS))

	for i := 0; i < len(REORDEREDTRANSACTIONS); i++ {
		for j := 0; j < len(REORDEREDTRANSACTIONS[i].CommandsInTransaction); j++ {
			if REORDEREDTRANSACTIONS[i].CommandsInTransaction[j].InstructionType == 0 {
				if TRANSACTIONDESIGNATION[i] != 2 {
					TRANSACTIONDESIGNATION[i] = 1
				}
			} else if REORDEREDTRANSACTIONS[i].CommandsInTransaction[j].InstructionType == 4 || REORDEREDTRANSACTIONS[i].CommandsInTransaction[j].InstructionType == 5 {
				TRANSACTIONDESIGNATION[i] = 2
			} else {
				//Do nothing
			}
		}
	}

	fmt.Println(TRANSACTIONDESIGNATION)

	//INSERT LOCKS IN-BETWEEN COMMANDS.
	EXCECUTIONREADYBATCH := make([][]interface{}, 0)

	XSLOCKEDTRANSACTION := make([]interface{}, 0)

	for i := 0; i < len(Transactions); i++ {
		for j := 0; j < len(Transactions[i].CommandsInTransaction); j++ {
			if Transactions[i].CommandsInTransaction[j].InstructionType == 1 {
				XSLOCKEDTRANSACTION = append(XSLOCKEDTRANSACTION, "RLOCK")
				XSLOCKEDTRANSACTION = append(XSLOCKEDTRANSACTION, Transactions[i].CommandsInTransaction[j])
				XSLOCKEDTRANSACTION = append(XSLOCKEDTRANSACTION, "RUNLOCK")
			} else {
				XSLOCKEDTRANSACTION = append(XSLOCKEDTRANSACTION, "LOCK")
				XSLOCKEDTRANSACTION = append(XSLOCKEDTRANSACTION, Transactions[i].CommandsInTransaction[j])
				XSLOCKEDTRANSACTION = append(XSLOCKEDTRANSACTION, "UNLOCK")
			}
		}
		EXCECUTIONREADYBATCH = append(EXCECUTIONREADYBATCH, XSLOCKEDTRANSACTION)
		XSLOCKEDTRANSACTION = make([]interface{}, 0)
	}

	//fmt.Println(EXCECUTIONREADYBATCH)

	//EXCECUTE TRANSACTION EXCECUTION QUEUE.
	/*for i := 0; i < len(EXCECUTIONREADYBATCH); i++ {
		for j := 0; j < len(EXCECUTIONREADYBATCH[i]); j++ {
			switch C := EXCECUTIONREADYBATCH[i][j].(type) {
			case string:
				if C == "RLOCK" {
					Lock, _ := MutexesMap.Load((EXCECUTIONREADYBATCH[i][j+1].(common.Command)).TableName())
					(Lock.(*sync.RWMutex)).RLock()
					fmt.Println("RLock found.")
				} else if C == "RUNLOCK" {
					Lock, _ := MutexesMap.Load((EXCECUTIONREADYBATCH[i][j-1].(common.Command)).TableName())
					(Lock.(*sync.RWMutex)).RUnlock()
					fmt.Println("RUnlock found.")
				} else if C == "LOCK" {
					Lock, _ := MutexesMap.Load((EXCECUTIONREADYBATCH[i][j+1].(common.Command)).TableName())
					(Lock.(*sync.RWMutex)).Lock()
					fmt.Println("Lock found.")
				} else if C == "UNLOCK" {
					Lock, _ := MutexesMap.Load((EXCECUTIONREADYBATCH[i][j-1].(common.Command)).TableName())
					(Lock.(*sync.RWMutex)).Unlock()
					fmt.Println("Unlock found.")
				}
			case common.Command:
				C.Instruction()
			default:
				fmt.Println("Unknown")
			}
		}
		fmt.Println("----")
	}
	*/
	transactionThreads = 5

	//fmt.Println(Semaphore)

	execWaitGroup.Add(2)
	go RunThread(1)
	go RunThread(2)
	execWaitGroup.Wait()
	execWaitGroup.Add(3)
	go RunThread(3)
	go RunThread(4)
	go RunThread(5)
	execWaitGroup.Wait()
	execWaitGroup.Add(2)
	go RunThread(6)
	go RunThread(7)
	execWaitGroup.Wait()

}

//RunThread runs a thread.
func RunThread(n int) {
	fmt.Printf("Running thread with id: %d \n", n)
	time.Sleep(time.Second * 5)
	execWaitGroup.Done()
}

Operations:
-INSERT
-CREATE
-DELETE
-DROP
-SELECT
-UPDATE

LOCK->X(Exclusive)(CREATE, INSERT, UPDATE, DELETE, DROP)
LOCK->S(Shared)(SELECT)
